{"./":{"url":"./","title":"简介","keywords":"","body":"介绍 记录一些个人感觉不错的文章 "},"Laravel-China/":{"url":"Laravel-China/","title":"Laravel China 精选文章","keywords":"","body":"介绍 Laravel China 是一个非常棒的 Laravel 社区，在站长的推动下，社区合力翻译了大量的国外优秀的文章，此处精选部分文章以分享。 "},"Laravel-China/20-个-Laravel-Eloquent-必备的实用技巧.html":{"url":"Laravel-China/20-个-Laravel-Eloquent-必备的实用技巧.html","title":"20 个 Laravel Eloquent 必备的实用技巧","keywords":"","body":"20 个 Laravel Eloquent 必备的实用技巧 Eloquent ORM 看起来是一个简单的机制，但是在底层，有很多半隐藏的函数和鲜为人知的方式来实现更多功能。在这篇文章中，我将演示几个小技巧。 1. 递增和递减 要代替以下实现： $article = Article::find($article_id); $article->read_count++; $article->save(); 你可以这样做： $article = Article::find($article_id); $article->increment('read_count'); 以下这些方法也可以实现： Article::find($article_id)->increment('read_count'); Article::find($article_id)->increment('read_count', 10); // +10 Product::find($produce_id)->decrement('stock'); // -1 2. 先执行 X 方法，X 方法执行不成功则执行 Y 方法 Eloquent 有相当一部分函数可以把两个方法结合在一起使用, 例如 『 请先执行 X 方法， X 方法执行不成功则执行 Y 方法 』。 实例 1 -- findOrFail(): 要替代以下代码的实现： $user = User::find($id); if (!$user) { abort (404); } 你可以这样写： $user = User::findOrFail($id); 实例 2 -- firstOrCreate(): 要替代以下代码的实现： $user = User::where('email', $email)->first(); if (!$user) { User::create([ 'email' => $email ]); } 这样写就可以了： $user = User::firstOrCreate(['email' => $email]); 3. 模型的 boot() 方法 在一个 Eloquent 模型中，有个神奇的地方，叫 boot()，在那里，你可以覆盖默认的行为： class User extends Model { public static function boot() { parent::boot(); static::updating(function($model) { // 写点日志啥的 // 覆盖一些属性，类似这样 $model->something = transform($something); }); } } 在创建模型对象时设置某些字段的值，大概是最受欢迎的例子之一了。 一起来看看在创建模型对象时，你想要生成 UUID 字段 该怎么做。 public static function boot() { parent::boot(); self::creating(function ($model) { $model->uuid = (string)Uuid::generate(); }); } 4. 带条件与排序的关联关系 定义关联关系的一般方式： public function users() { return $this->hasMany('App\\User'); } 你知道吗？也可以在上面的基础上增加 where 或者 orderBy?\\ 举个例子，如果你想关联某些类型的用户，同时使用 email 字段排序，你可以这样做： public function approvedUsers() { return $this->hasMany('App\\User')->where('approved', 1)->orderBy('email'); } 5. 模型特性：时间、追加等 Eloquent模型有些参数，使用类的属性形式。最常用是： class User extends Model { protected $table = 'users'; protected $fillable = ['email', 'password']; // 可以被批量赋值字段，如 User::create() 新增时，可使用字段 protected $dates = ['created_at', 'deleted_at']; // 需要被Carbon维护的字段名 protected $appends = ['field1', 'field2']; // json返回时，附加的字段 } 不只这些，还有： protected $primaryKey = 'uuid'; // 更换主键 public $incrementing = false; // 设置 不自增长 protected $perPage = 25; // 定义分页每页显示数量（默认15） const CREATED_AT = 'created_at'; const UPDATED_AT = 'updated_at'; //重写 时间字段名 public $timestamps = false; // 设置不需要维护时间字段 还有更多,我只列出了一些有意思的特性，具体参考文档 abstract Model class 了解所有特性. 6. 通过 ID 查询多条记录 所有人都知道 find() 方法，对吧？ $user = User::find(1); 我十分意外竟然很少人知道这个方法可以接受多个 ID 的数组作为参数： $users = User::find([1,2,3]); 7. WhereX 有一种优雅的方式能将这种代码： $users = User::where('approved', 1)->get(); 转换成这种： $users = User::whereApproved(1)->get(); 对，你没有看错，使用字段名作为后缀添加到 where 后面，它就能通过魔术方法运行了。 另外，在 Eloquent 里也有些和时间相关的预定义方法： User::whereDate('created_at', date('Y-m-d')); User::whereDay('created_at', date('d')); User::whereMonth('created_at', date('m')); User::whereYear('created_at', date('Y')); 8. 通过关系排序 一个复杂一点的「技巧」。你想对论坛话题按最新发布的帖子来排序？论坛中最新更新的主题在最前面是很常见的需求，对吧？ 首先，为主题的最新帖子定义一个单独的关系： public function latestPost() { return $this->hasOne(\\App\\Post::class)->latest(); } 然后，在控制器中，我们可以实现这个「魔法」： $users = Topic::with('latestPost')->get()->sortByDesc('latestPost.created_at'); 9. Eloquent::when() -- 不再使用 if-else 很多人都喜欢使用\"if-else\"来写查询条件，像这样： if (request('filter_by') == 'likes') { $query->where('likes', '>', request('likes_amount', 0)); } if (request('filter_by') == 'date') { $query->orderBy('created_at', request('ordering_rule', 'desc')); } 有一种更好的方法 -- 使用 when() $query = Author::query(); $query->when(request('filter_by') == 'likes', function ($q) { return $q->where('likes', '>', request('likes_amount', 0)); }); $query->when(request('filter_by') == 'date', function ($q) { return $q->orderBy('created_at', request('ordering_rule', 'desc')); }); 它可能看上去不是很优雅，但它强大的功能是传递参数： $query = User::query(); $query->when(request('role', false), function ($q, $role) { return $q->where('role_id', $role); }); $authors = $query->get(); 10. BelongsTo 默认模型 假如有一个 Post 模型附属于 Author 模型，在 Blade 模板里可以写作如下代码： {{ $post->author->name }} 但是如果作者被删除了，或者因为某些原因未设置？你就会得到一个错误信息，类似「不存在的对象属性」。 那么，你可以这么避免它： {{ $post->author->name ?? '' }} 但是你可以在 Eloquent 关系模型级别做到这种效果： public function author() { return $this->belongsTo('App\\Author')->withDefault(); } 这个例子中，如果帖子没有作者的话，author() 关系方法会返回一个空的 App\\Author 模型对象。 此外，我们还可以为默认模型分配一个默认的属性值。 public function author() { return $this->belongsTo('App\\Author')->withDefault([ 'name' => 'Guest Author' ]); } 11. 通过赋值函数进行排序 想象一下你有这样的代码: function getFullNameAttribute() { return $this->attributes['first_name'] . ' ' . $this->attributes['last_name']; } 现在,你想要通过 \"full_name\" 进行排序? 发现是没有效果的: $clients = Client::orderBy('full_name')->get(); //没有效果 解决办法很简单.我们需要在获取结果后对结果进行排序. $clients = Client::get()->sortBy('full_name'); // 成功! 注意的是方法名称是不相同的 -- 它不是orderBy,而是sortBy 12. 全局作用域下的默认排序 如果你想要 User::all() 总是按照 name 字段来排序呢？ 你可以给它分配一个全局作用域。让我们回到 boot() 这个我们在上文提到过的方法： protected static function boot() { parent::boot(); // 按照 name 正序排序 static::addGlobalScope('order', function (Builder $builder) { $builder->orderBy('name', 'asc'); }); } 扩展阅读 查询作用域 。 13. 原生查询方法 有时候，我们需要在 Eloquent 语句中添加原生查询。 幸运的是，确实有这样的方法。 // whereRaw $orders = DB::table('orders') ->whereRaw('price > IF(state = \"TX\", ?, 100)', [200]) ->get(); // havingRaw Product::groupBy('category_id')->havingRaw('COUNT(*) > 1')->get(); // orderByRaw User::where('created_at', '>', '2016-01-01') ->orderByRaw('(updated_at - created_at) desc') ->get(); 14. 复制：复制一行的副本 很简单。说明不是很深入，下面是复制数据库实体（一条数据）的最佳方法： $task = Tasks::find(1); $newTask = $task->replicate(); $newTask->save(); 15. Chunk() 方法之大块数据 与 Eloquent 不完全相关,它更多的关于 Collection (集合),但是对于处理大数据集合,仍然是很有用的。你可以使用 chunk() 将这些数据分割成小数据块 修改前: $users = User::all(); foreach ($users as $user) { // ... 你可以这样做: User::chunk(100, function ($users) { foreach ($users as $user) { // ... } }); 16. 创建模型的时候增加额外操作 我们都知道这条 Artisan 命令： php artisan make:model Company 但是你知道有三个十分有用的标志符可用于生成模型相关文件 php artisan make:model Company -mcr -m 创建迁移文件 -c 创建控制器文件 -r 为控制器添加资源操作方法 17. 调用 save 方法的时候指定 updated_at 你知道 ->save() 方法可以接受参数吗? 我们可以通过传入参数阻止它的默认行为：更新 updated_at 的值为当前时间戳。 $product = Product::find($id); $product->updated_at = '2019-01-01 10:00:00'; $product->save(['timestamps' => false]); 这样，我们成功在 save 时指定了 updated_at 的值。 18. update() 的结果是什么？ 你是否想知道这段代码实际上返回什么？ $result = $products->whereNull('category_id')->update(['category_id' => 2]); 我是说，更新操作是在数据库中执行的，但 $result 会包含什么？ 答案是受影响的行。 因此如果你想检查多少行受影响， 你不需要额外调用其他任何内容 -- update() 方法会给你返回此数字。 19. 把括号转换成 Eloquent 查询 如果你有个 and 和 or 混合的 SQL 查询，像这样子的： ... WHERE (gender = 'Male' and age >= 18) or (gender = 'Female' and age >= 65) 怎么用 Eloquent 来翻译它呢？ 下面是一种错误的方式： $q->where('gender', 'Male'); $q->orWhere('age', '>=', 18); $q->where('gender', 'Female'); $q->orWhere('age', '>=', 65); 顺序就没对。正确的打开方式稍微复杂点，使用闭包作为子查询： $q->where(function ($query) { $query->where('gender', 'Male') ->where('age', '>=', 18); })->orWhere(function($query) { $query->where('gender', 'Female') ->where('age', '>=', 65); }) 20. 复数参数的 orWhere 终于，你可以传递阵列参数给 orWhere()。平常的方式： $q->where('a', 1); $q->orWhere('b', 2); $q->orWhere('c', 3); 你可以这样做： $q->where('a', 1); $q->orWhere(['b' => 2, 'c' => 3]); 我很确定还有更多隐藏的秘诀，但我希望至少上面的其中一些对你来说是新的。 "},"Laravel-China/Laravel-的十八个最佳实践.html":{"url":"Laravel-China/Laravel-的十八个最佳实践.html","title":"Laravel 的十八个最佳实践","keywords":"","body":"Laravel 的十八个最佳实践 这篇文章并不是什么由 Laravel 改编的 SOLID 原则、模式等。 只是为了让你注意你在现实生活的 Laravel 项目中最常忽略的内容。 单一责任原则 一个类和一个方法应该只有一个职责。 错误的做法： public function getFullNameAttribute() { if (auth()->user() && auth()->user()->hasRole('client') && auth()->user()->isVerified()) { return 'Mr. ' . $this->first_name . ' ' . $this->middle_name . ' ' . $this->last_name; } else { return $this->first_name[0] . '. ' . $this->last_name; } } 正确的做法： public function getFullNameAttribute() { return $this->isVerifiedClient() ? $this->getFullNameLong() : $this->getFullNameShort(); } public function isVerifiedClient() { return auth()->user() && auth()->user()->hasRole('client') && auth()->user()->isVerified(); } public function getFullNameLong() { return 'Mr. ' . $this->first_name . ' ' . $this->middle_name . ' ' . $this->last_name; } public function getFullNameShort() { return $this->first_name[0] . '. ' . $this->last_name; } 强大的模型 & 简单控制器 如果你使用查询构造器或原始 SQL 来查询，请将所有与数据库相关的逻辑放入 Eloquent 模型或存储库类中。 坏： public function index() { $clients = Client::verified() ->with(['orders' => function ($q) { $q->where('created_at', '>', Carbon::today()->subWeek()); }]) ->get(); return view('index', ['clients' => $clients]); } 好： public function index() { return view('index', ['clients' => $this->client->getWithNewOrders()]); } class Client extends Model { public function getWithNewOrders() { return $this->verified() ->with(['orders' => function ($q) { $q->where('created_at', '>', Carbon::today()->subWeek()); }]) ->get(); } } 验证 将验证从控制器移动到请求类。 很常见但不推荐的做法： public function store(Request $request) { $request->validate([ 'title' => 'required|unique:posts|max:255', 'body' => 'required', 'publish_at' => 'nullable|date', ]); .... } 最好是这样： public function store(PostRequest $request) { .... } class PostRequest extends Request { public function rules() { return [ 'title' => 'required|unique:posts|max:255', 'body' => 'required', 'publish_at' => 'nullable|date', ]; } } 业务逻辑应该在服务类中 一个控制器必须只有一个职责，因此应该将业务逻辑从控制器移到服务类。 坏： public function store(Request $request) { if ($request->hasFile('image')) { $request->file('image')->move(public_path('images') . 'temp'); } .... } 好： public function store(Request $request) { $this->articleService->handleUploadedImage($request->file('image')); .... } class ArticleService { public function handleUploadedImage($image) { if (!is_null($image)) { $image->move(public_path('images') . 'temp'); } } } 不要重复你自己（DRY） 尽可能重用代码。 SRP（单一职责原则）正在帮助你避免重复。当然，这也包括了 Blade 模板、Eloquent 的范围等。 坏： public function getActive() { return $this->where('verified', 1)->whereNotNull('deleted_at')->get(); } public function getArticles() { return $this->whereHas('user', function ($q) { $q->where('verified', 1)->whereNotNull('deleted_at'); })->get(); } 好： public function scopeActive($q) { return $q->where('verified', 1)->whereNotNull('deleted_at'); } public function getActive() { return $this->active()->get(); } public function getArticles() { return $this->whereHas('user', function ($q) { $q->active(); })->get(); } 最好倾向于使用 Eloquent 而不是 Query Builder 和原生的 SQL 查询。要优先于数组的集合 Eloquent 可以编写可读和可维护的代码。此外，Eloquent 也拥有很棒的内置工具，比如软删除、事件、范围等。 比如你这样写： SELECT * FROM `articles` WHERE EXISTS (SELECT * FROM `users` WHERE `articles`.`user_id` = `users`.`id` AND EXISTS (SELECT * FROM `profiles` WHERE `profiles`.`user_id` = `users`.`id`) AND `users`.`deleted_at` IS NULL) AND `verified` = '1' AND `active` = '1' ORDER BY `created_at` DESC 还不如这样写： Article::has('user.profile')->verified()->latest()->get(); 批量赋值 比如你这样写： $article = new Article; $article->title = $request->title; $article->content = $request->content; $article->verified = $request->verified; // Add category to article $article->category_id = $category->id; $article->save(); Good: $category->article()->create($request->all()); &#x1F51D; Back to contents 不要在 Blade 模板中执行查询并使用关联加载（N + 1 问题） 不好的地方在于，这对于100 个用户来说，等于执行 101 个 DB 查询： @foreach (User::all() as $user) {{ $user->profile->name }} @endforeach 下面的做法，对于 100 个用户来说，仅仅只执行 2 个 DB 查询： $users = User::with('profile')->get(); ... @foreach ($users as $user) {{ $user->profile->name }} @endforeach 与其花尽心思给你的代码写注释，还不如对方法或变量写一个描述性的名称 坏： if (count((array) $builder->getQuery()->joins) > 0) 尚可： // Determine if there are any joins. if (count((array) $builder->getQuery()->joins) > 0) 好： if ($this->hasJoins()) 不要把 JS 和 CSS 放在 Blade 模板中，也不要将任何 HTML 放在 PHP 类中 坏： let article = `{{ json_encode($article) }}`; 尚可： Or {{ $article->name }} 最好的方法是使用在 Javascript 中这样来传输数据： let article = $('###article').val(); The best way is to use specialized PHP to JS package to transfer the data. 在代码中使用配置和语言文件、常量，而不是写死它 坏： public function isNormal() { return $article->type === 'normal'; } return back()->with('message', 'Your article has been added!'); 好： public function isNormal() { return $article->type === Article::TYPE_NORMAL; } return back()->with('message', __('app.article_added')); 使用社区接受的标准的 Laravel 工具 最好使用内置的 Laravel 功能和社区软件包，而不是其他第三方软件包和工具。因为将来与你的应用程序一起工作的开发人员都需要学习新的工具。另外，使用第三方软件包或工具的话，如果遇到困难，从 Laravel 社区获得帮助的机会会大大降低。不要让你的客户为此付出代价！ 任务 标准工具 第三方工具 授权 Policies Entrust, Sentinel and other packages 前端编译 Laravel Mix Grunt, Gulp, 3rd party packages 开发环境 Homestead Docker 部署 Laravel Forge Deployer and other solutions 单元测试 PHPUnit, Mockery Phpspec 浏览器测试 Laravel Dusk Codeception 数据库操作 Eloquent SQL, Doctrine 模板 Blade Twig 数据操作 Laravel collections Arrays 表单验证 Request classes 3rd party packages, validation in controller 认证 Built-in 3rd party packages, your own solution API 认证 Laravel Passport 3rd party JWT and OAuth packages 创建 API Built-in Dingo API and similar packages 数据库结构操作 Migrations Working with DB structure directly 局部化 Built-in 3rd party packages 实时用户接口 Laravel Echo, Pusher 3rd party packages and working with WebSockets directly Generating testing data Seeder classes, Model Factories, Faker Creating testing data manually 生成测试数据 Laravel Task Scheduler Scripts and 3rd party packages 数据库 MySQL, PostgreSQL, SQLite, SQL Server MongoDB 遵循Laravel命名约定 遵循 PSR 标准。 另外，请遵循 Laravel 社区接受的命名约定： 类型 规则 正确示例 错误示例 Controller singular ArticleController ArticlesController Route plural articles/1 article/1 Named route snake_case with dot notation users.show_active users.show-active, show-active-users Model singular User Users hasOne or belongsTo relationship singular articleComment articleComments, article_comment All other relationships plural articleComments articleComment, article_comments Table plural article_comments article_comment, articleComments Pivot table singular model names in alphabetical order article_user user_article, articles_users Table column snake_case without model name meta_title MetaTitle; article_meta_title Model property snake_case $model->created_at $model->createdAt Foreign key singular model name with _id suffix article_id ArticleId, id_article, articles_id Primary key - id custom_id Migration - 2017_01_01_000000_create_articles_table 2017_01_01_000000_articles Method camelCase getAll get_all Method in resource controller table store saveArticle Method in test class camelCase testGuestCannotSeeArticle test_guest_cannot_see_article Variable camelCase $articlesWithAuthor $articles_with_author Collection descriptive, plural $activeUsers = User::active()->get() $active, $data Object descriptive, singular $activeUser = User::active()->first() $users, $obj Config and language files index snake_case articles_enabled ArticlesEnabled; articles-enabled View snake_case show_filtered.blade.php showFiltered.blade.php, show-filtered.blade.php Config snake_case google_calendar.php googleCalendar.php, google-calendar.php Contract (interface) adjective or noun Authenticatable AuthenticationInterface, IAuthentication Trait adjective Notifiable NotificationTrait 尽可能使用更短、更易读的语法 坏： $request->session()->get('cart'); $request->input('name'); 好： session('cart'); $request->name; 更多示例： 通用语法 更短、更可读的语法 Session::get('cart') session('cart') $request->session()->get('cart') session('cart') Session::put('cart', $data) session(['cart' => $data]) $request->input('name'), Request::get('name') $request->name, request('name') return Redirect::back() return back() is_null($object->relation) ? $object->relation->id : null } optional($object->relation)->id return view('index')->with('title', $title)->with('client', $client) return view('index', compact('title', 'client')) $request->has('value') ? $request->value : 'default'; $request->get('value', 'default') Carbon::now(), Carbon::today() now(), today() App::make('Class') app('Class') ->where('column', '=', 1) ->where('column', 1) ->orderBy('created_at', 'desc') ->latest() ->orderBy('age', 'desc') ->latest('age') ->orderBy('created_at', 'asc') ->oldest() ->select('id', 'name')->get() ->get(['id', 'name']) ->first()->name ->value('name') 使用 IoC 容器或 facades 代替新的 Class 新的 Class 语法创建类时，不仅使得类与类之间紧密耦合，还加重了测试的复杂度。推荐改用 IoC 容器或 facades。 坏： $user = new User; $user->create($request->all()); 好： public function __construct(User $user) { $this->user = $user; } .... $this->user->create($request->all()); 不要直接从 .env 文件获取数据 将数据传递给配置文件，然后使用辅助函数 config() 在应用程序中使用数据。 坏： $apiKey = env('API_KEY'); Good: // config/api.php 'key' => env('API_KEY'), // Use the data $apiKey = config('api.key'); 以标准格式存储日期，必要时就使用访问器和修改器来修改日期格式 坏： {{ Carbon::createFromFormat('Y-d-m H-i', $object->ordered_at)->toDateString() }} {{ Carbon::createFromFormat('Y-d-m H-i', $object->ordered_at)->format('m-d') }} 坏： // Model protected $dates = ['ordered_at', 'created_at', 'updated_at'] public function getSomeDateAttribute($date) { return $date->format('m-d'); } // View {{ $object->ordered_at->toDateString() }} {{ $object->ordered_at->some_date }} 其他良好做法 千万不要在路由文件中放置任何逻辑。 在 Blade 模板中最小化 vanilla PHP 的使用。 本文章首发在 Laravel China 社区 Stay Hungry, Stay Foolish. "},"Laravel-China/如何使用-Laravel-Collections-类编写神级代马.html":{"url":"Laravel-China/如何使用-Laravel-Collections-类编写神级代马.html","title":"如何使用 Laravel Collections 类编写神级代码","keywords":"","body":"如何使用 Laravel Collections 类编写神级代码 Laravel 提供了一些超赞的组件，在我看来，它是目前所有 Web 框架中提供组件支持最好的一个。它不仅提供了开箱即用的视图（views）、身份认证（authentication）、会话（sessions）、缓存（caching）、Eloquent、队列（queues）、数据校验（data validation）等组件。甚至还提供了开发工具（Valet 和 Homestead）。 但是，这个框架功能中最强大的一个特性常常被萌新们视而不见 - Collection（集合） 类。在这篇文章，我们将探寻如何使用集合提升编码效率、代码的易读行，及编写出更精简的编码。 预览 最初接触到使用集合的场景来自于研发人员使用 Eloquent 执行数据库查询，并从返回数据中使用 foreach 语句遍历获取模型集合。 不过，初学者可能并没有注意到，集合提供了超过 90 个以上的方法来操作底层数据。更妙的是几乎所有的方法都支持链式操作，能够让你的代码读起来就像一篇散文一样。这样使得你的代码更易阅读，无论是你还是其他使用者都是如此。 还没有进入正题？好吧，让我们回顾一个简单的代码片段，来看看我们如何使用集合编写粗、快、猛的代码吧。 代码示例 让我们构建一个真实的世界。假设我们查询某些 API 接口并获取到如下以数组保存的结果集： 'John', 'last_name' => 'Doe', 'age' => 'twenties'], ['first_name' => 'Fred', 'last_name' => 'Ali', 'age' => 'thirties'], ['first_name' => 'Alex', 'last_name' => 'Cho', 'age' => 'thirties'], ]; 我们看到数组包含名字（first name）、姓氏（last name） 和年龄（age）范围。现在，我们假设从记录中获取一名 年龄（age） 为 30 岁（thirties） 的用户，然后依据 姓氏（last name） 进行 排序（sort）。最后，我们还希望返回的结果为 一个字符串（single string），这样每个用户独占 一行（new line）。最后，我们还希望返回的结果为 这个需求看起来不难实现，现在让我们看看使用 PHP 如何实现这一功能： // 依据姓氏排序 usort($data, function ($item1, $item2) { return $item1['last_name'] $item2['last_name']; }); // 依据年龄范围分组 $new_data = []; foreach ($data as $key => $item) { $new_data[$item['age']][$key] = $item; } ksort($new_data, SORT_NUMERIC); // 从年龄为 30 岁组里获取用户全名 $result = array_map(function($item) { return $item['first_name'].' '.$item['last_name']; }, $new_data['thirties']); // 将数组转换为字符串并以行分隔符分隔 $final = implode(\"\\n\", $result); // 译注：原文是 $final = implode($results, \"\\n\"); implode函数接收两种顺序的参数，为了保持与文档一致所以我这边做了调整。 我们的实现代码超过 20 行，并且很不优雅。移除掉注释及换行相关代码，这段代码会变得难以阅读。再者，我们还需要借助临时变量以及 PHP 中内置的不友好的 sort 方法。 现在，让我们看下借助 Collection 类实现起来是多么简单吧： collection($data)->where('age', 'thirties') ->sortBy('last_name') ->map(function($item){ return $item['first_name'].' '.$item['last_name']; }) ->implode(\"\\n\"); 哇哦！我们的代码从 20 行变成了 6 行。现在的代码不仅顺畅不少，并且在方法实现时无需借助注释告诉我们它们在处理什么问题。 不过，还存在一个问题阻止我们的代码不如完美阶段... 就是用于比较 first name 和 last name 的 map 方法。坦白说，这真的不是什么大问题，但是它为我们探索 macro（宏） 概念提供了动力。 扩展集合（Extending Collections） Collection 类，同其它 Laravel 组件一样，支持宏（macroable），就是说你可以给它添加方法随后使用。 提示： 如果你希望新方法随处可用，你应该将它们添加到服务提供中。我喜欢创建一个 MacroServiceProvider 实先这个功能，对于你来说随你喜欢就好。 让我们添加一个方法它会连接由数组提供的任意数量的字段并返回字符串结果： Collection::macro('toConcatenatedString', function ($fields = [], $separator = ' ') { return $this->map(function($item) use ($fields, $separator) { return implode($separator, array_map(function ($el) use ($item) { return $item[$el]; }, $fields) ); })->implode(\"\\n\"); }); 添加完这个方法后，我们的代码基本上就完美了： collect($data)->where('age', 'thirties') ->sortBy('last_name') ->toConcatenatedString(['first_name', 'last_name']); 我们的代码从混乱的 20 多行精简到了 3 行，代码干净整洁功能清晰任何人都可以立马理解。 又一个示例 现在让我们看下第二个示例，假设我们一个用户列表，我们需要基于角色（role）过滤出来，然后进一步如果他们的注册时间为 5 年或以上且 last name 以字母 A-M 开始的仅获取第一个用户。 数据类似如下： 'John Doe', 'role' => 'vip', 'years' => 7], ['name' => 'Fred Ali', 'role' => 'vip', 'years' => 3], ['name' => 'Alex Cho', 'role' => 'user', 'years' => 9], ]; 如果我们使用的是 PHP 实现，我们的代码看下来如下： $subset = []; foreach ($users as $user) { if ($user['role'] === 'vip' && $user['years'] >= 5) { if (preg_match('/\\s[A-Z]/', $user['name'])) { $subset[] = $user; } } } return reset($subset) 注意： 你可以将第二个 if 语句移至第一个里面，但是我个人喜欢在单个 if 语句中使用不超过两个条件语句，因为我认为超过 2 个条件语句回事代码难以阅读。 这段代码不至于太糟糕，但是我们依然需要使用临时变量，我们还需要使用 reset 函数将指针重置到第一个用户。我们的代码还有四层缩进，这使得代码解析变得更有挑战性。 相反，我们来看看集合是如何处理这个问题的： collect($users)->where('role', 'vip') ->map(function($user) { return preg_match('/\\s[A-Z]/', $user['name']); }) ->firstWhere('years', '>=', '5'); 我们将代码简化到了之前的一般左右，每一步过滤处理清晰明了，并且我们不需要引入临时变量。 遗憾的是目前集合还不支持正则匹配，所以我们使用 map 方法，不过我们可以为这个功能创建一个宏： Collection::macro('whereRegex', function($expression, $field) { return $this->map(function ($item) use ($expression, $field) { return preg_match($expression, $item[$field]); }) }); 得益于宏方法，我们的代码现在看起来如下： collect($users)->where('role', 'vip') ->whereRegex('/\\s[A-Z]/', 'name') ->firstWhere('years', '>=', 5); 注意： 为了简单起见，我们的红仅仅适用于数组集合。如果你计划让它们可以在 Eloquent 集合上使用，你需要在此场景下做相应的代码处理才行。 不同的视角 我们可以继续列出无数的示例，但仍然无法涵盖所有可用的集合方法，并且这从来都不是本文的真正目的。 需要注意的是，通过使用 Collection 类，您不仅可以获得一个方法库来简化编程工作，还可以选择一种从根本上改善代码的方法。 你会情不自禁的将你的代码结构从代码块重构简化成一行，同时减少代码的缩进，临时变量的使用和技巧性方法，另外你还可以使用链式编程方法，这让你的代码更加便于阅读和解析，此外最重要的是减少了编码工作！ 查看官方文档获取更多这个迷人的类库的使用细节：https://laravel-china.org/docs/laravel/collections "}}